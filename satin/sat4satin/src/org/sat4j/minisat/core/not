Solver.java:

    public SolverState
    spawn_satinRecSearch2(SolverState state,
			  long nofConflicts, long nofLearnts, long conflictC,
			  int p, int satinDepth)
    {
	Lbool res;
	Solver solver;

	solver = reconstruct_from_state(state);

	// Make the decision specified, and continue searching
	System.out.println("spawn level " + satinDepth + " assume " + p);

	solver.slistener.assuming(decode2dimacs(p));
	boolean ret = solver.assume(p);
	// if (!ret) {
	//    // Temp hack:
	//     return Lbool.FALSE;
	// }
	assert ret;

	res = satinRecSearch(nofConflicts, nofLearnts, conflictC, satinDepth);
	System.err.println(state.name + ": SATIN result: " + res);
        // stats.printStat(System.out, "");

	state.satin_res = res;
	// Return entire solver state so that caller can easily fetch model,
	// learnt clauses, statistics, etc.
	return state;
    }




		} else {
		    SolverState s1 = new SolverState(this);
		    SolverState s2 = new SolverState(this);

		    s1.name = this.name + child_depth + "-" + localDepth + "a";
		    SolverState res1 = 
			spawn_satinRecSearch2(s1,
					      child_nofConflicts,
					      nofLearnts,
					      conflictC,
					      p,	// selected assignment
					      child_depth);

		    s2.name = this.name + child_depth + "-" + localDepth + "b";
		    SolverState res2 =
			spawn_satinRecSearch2(s2,
					      child_nofConflicts,
					      nofLearnts,
					      conflictC,
					      p ^ 1, // the other assignment
					      child_depth);
		    sync();

		    System.out.println("synced " +
				       s1.name + ": " + res1.satin_res + ", " +
				       s2.name + ": " + res2.satin_res);
		    stats.addStats(res1.stats);
		    stats.addStats(res2.stats);
		    if (res1.satin_res == Lbool.TRUE ||
			res2.satin_res == Lbool.TRUE)
		    {
			// model found
			System.err.println(this.name +
					   ": satin model found: SAT");
			if (res1.satin_res == Lbool.TRUE) {
			    model = res1.model.clone();
			} else {
			    model = res2.model.clone();
			}
			return Lbool.TRUE;
		    }
		    else if (res1.satin_res == Lbool.UNDEFINED ||
			     res2.satin_res == Lbool.UNDEFINED)
		    {
			// timeout
			System.err.println(this.name + ": satin UNDEF");
			return Lbool.UNDEFINED;
		    } else {
			// Unsat
			System.err.println(this.name + ": satin UNSAT");
			return Lbool.FALSE;
		    }
		    
		}


SolverInterface2.java:

package org.sat4j.minisat.core;

interface solverSatinInterface2 extends ibis.satin.Spawnable {
  SolverState spawn_satinRecSearch2(SolverState state,
				    long nofConflicts, long nofLearnts,
				    long conflictC, int p, int satinDepth);
}


SolverState.java

package org.sat4j.minisat.core;

import java.io.PrintStream;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.Timer;
import java.util.TimerTask;
// for serialClone:
import java.io.*;

import org.sat4j.core.Vec;
import org.sat4j.core.VecInt;
import org.sat4j.minisat.orders.VarOrder;
import org.sat4j.minisat.orders.VarOrder;
import org.sat4j.specs.ContradictionException;
import org.sat4j.specs.IConstr;
import org.sat4j.specs.ISolver;
import org.sat4j.specs.IVec;
import org.sat4j.specs.IVecInt;
import org.sat4j.specs.TimeoutException;

//
import org.sat4j.minisat.core.ActivityComparator;

public class SolverState implements Serializable, Cloneable
{
    protected static final long serialVersionUID = 1L;

    protected static final double CLAUSE_RESCALE_FACTOR = 1e-20;

    protected static final double CLAUSE_RESCALE_BOUND = 1 / CLAUSE_RESCALE_FACTOR;

    protected IVec<Constr> constrs = new Vec<Constr>(); // Constr

    protected IVec<Constr> learnts = new Vec<Constr>(); // Clause

    protected double claInc = 1.0;

    protected double claDecay = 1.0;

    protected int qhead = 0;

    protected IVecInt trail = new VecInt(); // lit

    protected IVecInt trailLim = new VecInt(); // int

    protected int rootLevel;

    protected int[] model = null;

    protected ILits voc;

    protected IOrder order;

    protected String name;

    protected final Comparator<Constr> comparator = new ActivityComparator();

    protected SolverStats stats = new SolverStats();

    protected LearningStrategy learner;

    protected AssertingClauseGenerator analyzer;

    protected boolean undertimeout;

    protected int timeout = Integer.MAX_VALUE;

    protected DataStructureFactory dsfactory;

    protected SearchParams params;

    protected IVecInt __dimacs_out = new VecInt();

    protected SearchListener slistener = new NullSearchListener();

    protected boolean[] seen = new boolean[0];

    protected IVecInt preason = new VecInt();

    protected IVecInt outLearnt = new VecInt();

    protected ISimplifier simplifier;

    protected double timebegin = 0;

    protected Lbool satin_res;

    public void reset() {
    }

    public void printStat(PrintStream out, String prefix) {
    }

    public String toString(String prefix) {
	return "SolverState";
    }

    public SolverState(Solver solver)
    {
	SolverState state;

	state = this;

	state.analyzer = solver.analyzer;
	state.learner = solver.learner;

	// state.claInc       = solver.claInc;
	// state.claDecay     = solver.claDecay;
	// state.qhead        = solver.qhead;
	// state.rootLevel    = solver.rootLevel;
	// state.undertimeout = solver.undertimeout;
	// state.timeout      = solver.timeout;
	// state.slistener    = solver.slistener;
	state.simplifier   = solver.simplifier;
	state.order    = (IOrder)       solver.order.clone();
	state.stats    = (SolverStats)  solver.stats.clone();
	state.trail    = (IVecInt)      solver.trail.clone();
	state.trailLim = (IVecInt)      solver.trailLim.clone();
	if (solver.model != null) {
	    // typically you won't clone a solver that already has a model, but anyway..
	    state.model = (int[])       solver.model.clone();
	}

	// Next already done in constructor via dsfactory.clone!!
	// state.voc       = (ILits)     solver.voc.clone();
	state.seen         = (boolean[]) solver.seen.clone();
	state.preason      = (IVecInt)   solver.preason.clone();
	state.outLearnt    = (IVecInt)   solver.outLearnt.clone();
	state.__dimacs_out = (IVecInt)   solver.__dimacs_out.clone();

	state.name = solver.name;

	// state.comparator       = (Comparator<Constr>) solver.comparator.clone();
	// state.comparator       = solver.comparator;
	// state.learntConstraint = (Handle<Constr>) solver.learntConstraint.clone();
	// state.learntConstraint = solver.learntConstraint;

	// Extra tweaks to restore concistency of the datastructures:
	// System.out.println("Dsf: " + state.dsfactory);
	state.dsfactory = (DataStructureFactory) state.dsfactory.clone();
	// System.out.println("Dsf: " + state.dsfactory);

        // state.dsfactory.setUnitPropagationListener(clone);
        // state.dsfactory.setLearner(clone);
        state.voc = state.dsfactory.getVocabulary();
        state.order.setLits(state.voc);

	state.constrs  = (IVec<Constr>) solver.constrs.clone();

	state.params = (SearchParams) solver.params.clone();

	// System.err.println(state.name + ": constrs = " + state.constrs + 
	// 		   " (orig " + this.constrs + ")" +
	// 		   " size " + state.constrs.size());
	for (int i = 0; i < state.constrs.size(); i++) {
	    Constr c = state.constrs.get(i);
	    Constr old = constrs.get(i);

	    c.setVoc(state.voc, old);

	    // Need to reconstruct watches since the clause has been cloned
	    state.voc.watch(c.get(0) ^ 1, c);
	    state.voc.watch(c.get(1) ^ 1, c);
	}

	state.learnts  = (IVec<Constr>) this.learnts.clone();
	// System.err.println(state.name + ": learnts = " + state.learnts + 
	//		   " (orig " + this.learnts + ")" +
	//		   " size " + state.learnts.size());
	for (int i = 0; i < state.learnts.size(); i++) {
	    Constr c = state.learnts.get(i);
	    Constr old = learnts.get(i);

	    c.setVoc(state.voc, old);

	    // Need to reconstruct watches since the clause has been cloned
	    state.voc.watch(c.get(0) ^ 1, c);
	    state.voc.watch(c.get(1) ^ 1, c);
	}
    }
 }

    public Solver reconstruct_from_state(SolverState state)
    {
        Solver solver;

	solver = new Solver(state.analyzer,  // .clone(),
		       state.learner,   // .clone(),
		       // (DataStructureFactory) this.dsfactory.clone(),
		       state.dsfactory,
		       state.params,    // .clone(),
		       (IOrder) state.order.clone()
		       );

	solver.name         = state.name;

	solver.claInc       = state.claInc;
	solver.claDecay     = state.claDecay;
	solver.qhead        = state.qhead;
	solver.rootLevel    = state.rootLevel;
	solver.undertimeout = state.undertimeout;
	solver.timeout      = state.timeout;
	solver.slistener    = state.slistener;
	solver.simplifier   = state.simplifier;

	solver.order    = (IOrder)       state.order.clone();
	solver.stats    = (SolverStats)  state.stats.clone();
	solver.trail    = (IVecInt)      state.trail.clone();
	solver.trailLim = (IVecInt)      state.trailLim.clone();
	if (state.model != null) {
	    // typically you won't clone a solver that already has a model, but anyway..
	    solver.model = (int[])       state.model.clone();
	}

	// Next already done in constructor via dsfactory.clone!!
	// solver.voc       = (ILits)     state.voc.clone();
	solver.seen         = (boolean[]) state.seen.clone();
	solver.preason      = (IVecInt)   state.preason.clone();
	solver.outLearnt    = (IVecInt)   state.outLearnt.clone();
	solver.__dimacs_out = (IVecInt)   state.__dimacs_out.clone();

	// solver.comparator       = (Comparator<Constr>) state.comparator.clone();
	// solver.comparator       = state.comparator;
	// solver.learntConstraint = (Handle<Constr>) state.learntConstraint.clone();
	// solver.learntConstraint = state.learntConstraint;

	// Extra tweaks to restore concistency of the datastructures:
	// System.out.println("Dsf: " + solver.dsfactory);
	solver.dsfactory = (DataStructureFactory) state.dsfactory.clone();
	// System.out.println("Dsf: " + state.dsfactory);
        solver.dsfactory.setUnitPropagationListener(solver);
        solver.dsfactory.setLearner(solver);
        solver.voc = state.dsfactory.getVocabulary();
        solver.order.setLits(solver.voc);

	solver.constrs  = (IVec<Constr>) state.constrs.clone();
	// System.err.println(state.name + ": constrs = " + clone.constrs + 
	// 		   " (orig " + state.constrs + ")" +
	// 		   " size " + state.constrs.size());
	for (int i = 0; i < solver.constrs.size(); i++) {
	    Constr c = solver.constrs.get(i);
	    Constr old = constrs.get(i);

	    c.setVoc(solver.voc, old);

	    // Need to reconstruct watches since the clause has been cloned
	    solver.voc.watch(c.get(0) ^ 1, c);
	    solver.voc.watch(c.get(1) ^ 1, c);
	}

	solver.learnts  = (IVec<Constr>) state.learnts.clone();
	// System.err.println(state.name + ": learnts = " + state.learnts + 
	//		   " (orig " + state.learnts + ")" +
	//		   " size " + state.learnts.size());
	for (int i = 0; i < solver.learnts.size(); i++) {
	    Constr c = solver.learnts.get(i);
	    Constr old = learnts.get(i);

	    c.setVoc(solver.voc, old);

	    // Need to reconstruct watches since the clause has been cloned
	    solver.voc.watch(c.get(0) ^ 1, c);
	    solver.voc.watch(c.get(1) ^ 1, c);
	}

	return solver;
    }


